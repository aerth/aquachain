package alerts

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"time"

	"net/http"
	"os"
	"strings"

	"gitlab.com/aquachain/aquachain/common/log"
)

type AlertConfig struct {
	Platform string // tg, email, sms
	Token    string
	Channel  string // tg is number
}

func (a AlertConfig) Enabled() bool {
	return a.Platform != "" && a.Token != "" && a.Channel != ""
}

var mainCfg AlertConfig

func Infof(f string, i ...any) {
	if !mainCfg.Enabled() {
		log.Warn("alerts not configured:", "msg", fmt.Sprintf(f, i...))
		return
	}
	msg := fmt.Sprintf(f, i...)
	log.Info("Alert Info", "message", msg)
	mainCfg.Send(msg)
}

func Warnf(f string, i ...any) {
	if true || !mainCfg.Enabled() {
		log.Warn("alerts not configured:", "msg", fmt.Sprintf(f, i...))
		return
	}
	msg := fmt.Sprintf(f, i...)
	log.Warn("Alert Warning", "message", msg)
	mainCfg.Send(msg)
}

func ParseAlertConfig() (AlertConfig, error) {
	if mainCfg.Enabled() {
		panic("already configured")
	}
	var ac AlertConfig
	ac.Platform = os.Getenv("ALERT_PLATFORM")
	ac.Token = os.Getenv("ALERT_TOKEN")
	ac.Channel = os.Getenv("ALERT_CHANNEL")
	if ac.Platform == "" {
		return ac, fmt.Errorf("missing ALERT_PLATFORM")
	}
	if ac.Token == "" {
		return ac, fmt.Errorf("missing ALERT_TOKEN")
	}
	if ac.Channel == "" {
		return ac, fmt.Errorf("missing ALERT_CHANNEL")
	}
	switch ac.Platform {
	case "tg", "telegram": // alias
		ac.Platform = "tg"
	default:
		return ac, fmt.Errorf("unsupported ALERT_PLATFORM: %q", ac.Platform)
	}
	if len(ac.Token) < 10 {
		return ac, fmt.Errorf("invalid token: %s", ac.Token)
	}
	if len(ac.Channel) < 5 {
		return ac, fmt.Errorf("invalid channel: %s", ac.Channel)
	}
	mainCfg = ac
	return ac, nil
}
func MustParseAlertConfig() AlertConfig {
	ac, err := ParseAlertConfig()
	if err != nil {
		fmt.Fprintf(os.Stderr, "\nfatal: failed to parse alert config: %v\n", err)
		os.Exit(1)
	}
	return ac
}

var ErrAlertTimeout = fmt.Errorf("alert timeout")

func (ac AlertConfig) Send(msg string) error {
	if !ac.Enabled() {
		log.Warn("(warn) alerts not configured: alert=%s", msg)
		return nil
	}
	switch ac.Platform {
	case "tg":
		short, cancel := context.WithTimeoutCause(context.Background(), 5*time.Second, ErrAlertTimeout)
		defer cancel()
		return sendTelegram(short, ac.Token, ac.Channel, msg)
	default:
		panic("unsupported alert platform: " + ac.Platform)
	}
	return nil
}

// Generated by curl-to-Go: https://mholt.github.io/curl-to-go

// curl -X POST \
//      -H 'Content-Type: application/json' \
//      -d '{"chat_id": "123456789", "text": "This is a test from curl", "disable_notification": true}' \
//      https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage

type Payload struct {
	ChatID              string `json:"chat_id"`
	Text                string `json:"text"`
	DisableNotification bool   `json:"disable_notification"`
}

func (p Payload) Bytes() []byte {
	b, err := json.Marshal(p)
	if err != nil {
		panic(err.Error())
	}
	return b
}
func (p Payload) Reader() io.Reader {
	return bytes.NewReader(p.Bytes())
}

func sendTelegram(ctx context.Context, token string, channelsinput string, msg string) error {
	channels := strings.Split(channelsinput, ",")
	for _, channel := range channels {
		channel = strings.TrimSpace(channel)
		data := Payload{
			ChatID:              channel,
			Text:                msg,
			DisableNotification: false,
		}
		endpoint := fmt.Sprintf("https://api.telegram.org/bot%s/sendMessage", token)
		req, err := http.NewRequestWithContext(ctx, http.MethodPost, endpoint, data.Reader())
		if err != nil {
			if ctx.Err() != nil {
				return context.Cause(ctx) // is timeout etc
			}
			return err
		}
		req.Header.Set("Content-Type", "application/json")
		resp, err := http.DefaultClient.Do(req)
		if err != nil { // maybe bad markdown, send a simple message as a fallback
			if ctx.Err() != nil {
				return context.Cause(ctx) // is timeout etc
			}
			log.Info("failed to send chain alert", "msg", data.Text, "error", err.Error())
			return err
		}
		resp.Body.Close()
		if resp.StatusCode != http.StatusOK {
			return fmt.Errorf("unexpected status code: %d", resp.StatusCode)
		}

	}
	return nil
}
