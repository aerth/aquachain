package alerts

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"time"

	"net/http"
	"os"
	"strings"

	"gitlab.com/aquachain/aquachain/common/log"
)

type AlertConfig struct {
	Platform string // tg, email, sms
	Token    string
	Channel  string // tg is number
}

func (a AlertConfig) Enabled() bool {
	return a.Platform != "" && a.Token != "" && a.Channel != ""
}

var mainCfg AlertConfig

// Infof logs a warning message and sends an alert via ALERT_PLATFORM if configured (see ParseAlertConfig)
func Infof(f string, i ...any) {
	if !mainCfg.Enabled() {
		log.Info("new alert system not configured", "msg", strings.TrimSpace(strings.Replace(fmt.Sprintf(f, i...), "\n", " ", -1)))
		return
	}
	msg := fmt.Sprintf(f, i...)
	log.Info("Alert Info", "message", msg)
	mainCfg.Send(msg)
}

// Warnf logs a warning message and sends an alert via ALERT_PLATFORM if configured (see ParseAlertConfig)
func Warnf(f string, i ...any) {
	if !mainCfg.Enabled() {
		log.Warn("new alert system not configured", "msg", strings.TrimSpace(strings.Replace(fmt.Sprintf(f, i...), "\n", " ", -1)))
		return
	}
	msg := fmt.Sprintf(f, i...)
	log.Warn("Alert Warning", "message", msg)
	mainCfg.Send(msg)
}

func ParseAlertConfig() (AlertConfig, error) {
	if mainCfg.Enabled() {
		panic("already configured")
	}
	var ac AlertConfig
	ac.Platform = os.Getenv("ALERT_PLATFORM")
	ac.Token = os.Getenv("ALERT_TOKEN")
	ac.Channel = os.Getenv("ALERT_CHANNEL")
	if ac.Platform == "" {
		return ac, fmt.Errorf("missing ALERT_PLATFORM")
	}
	if ac.Token == "" {
		return ac, fmt.Errorf("missing ALERT_TOKEN")
	}
	if ac.Channel == "" {
		return ac, fmt.Errorf("missing ALERT_CHANNEL")
	}
	switch ac.Platform {
	case "tg", "telegram": // alias
		ac.Platform = "tg"
		if len(ac.Token) < 10 {
			return ac, fmt.Errorf("invalid token: %s", ac.Token)
		}
		if len(ac.Channel) < 5 {
			return ac, fmt.Errorf("invalid channel: %s", ac.Channel)
		}
	case "none", "": // alias
		ac.Platform = ""
	default:
		return ac, fmt.Errorf("unsupported ALERT_PLATFORM: %q", ac.Platform)
	}
	if ac.Token == "" {
		return ac, fmt.Errorf("missing ALERT_TOKEN")
	}
	if !ac.Enabled() {
		log.Warn("alerts not configured")
		return ac, fmt.Errorf("alerts not configured")
	}
	mainCfg = ac
	return ac, nil
}
func MustParseAlertConfig() AlertConfig {
	ac, err := ParseAlertConfig()
	if err != nil {
		fmt.Fprintf(os.Stderr, "\nfatal: failed to parse alert config: %v\n", err)
		os.Exit(1)
	}
	return ac
}

var ErrAlertTimeout = fmt.Errorf("alert timeout")

func (ac AlertConfig) Send(msg string, donefns ...func()) error {
	wait := len(donefns) == 0
	println("test", msg, wait, ac.Platform, ac.Token, ac.Channel)
	switch ac.Platform {
	case "none", "":
		println("alert notification", msg)
		return nil
	case "tg":
		println("sending tg")
		short, cancel := context.WithTimeoutCause(context.Background(), 5*time.Second, ErrAlertTimeout)
		if wait {
			defer cancel()
			return _sendTelegram(short, ac.Token, ac.Channel, msg)
		}
		donefns = append(donefns, cancel)
		go sendTelegram(short, ac.Token, ac.Channel, msg, donefns...)
		return nil
	default:
		panic("unsupported alert platform: " + ac.Platform)
	}
}

// Generated by curl-to-Go: https://mholt.github.io/curl-to-go

// curl -X POST \
//      -H 'Content-Type: application/json' \
//      -d '{"chat_id": "123456789", "text": "This is a test from curl", "disable_notification": true}' \
//      https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage

type Payload struct {
	ChatID              string `json:"chat_id"`
	Text                string `json:"text"`
	DisableNotification bool   `json:"disable_notification"`
}

func (p Payload) Bytes() []byte {
	b, err := json.Marshal(p)
	if err != nil {
		panic(err.Error())
	}
	return b
}
func (p Payload) Reader() io.Reader {
	return bytes.NewReader(p.Bytes())
}

func sendTelegram(ctx context.Context, token string, channels string, msg string, donefns ...func()) {
	if err := _sendTelegram(ctx, token, channels, msg); err != nil {
		log.Error("failed to send telegram alert", "err", err.Error())
	}
	for _, fn := range donefns {
		fn()
	}
}

func _sendTelegram(ctx context.Context, token string, channelsinput string, msg string) error {
	channels := strings.Split(channelsinput, ",")
	for _, channel := range channels {
		channel = strings.TrimSpace(channel)
		data := Payload{
			ChatID:              channel,
			Text:                msg,
			DisableNotification: false,
		}
		endpoint := fmt.Sprintf("https://api.telegram.org/bot%s/sendMessage", token)
		req, err := http.NewRequestWithContext(ctx, http.MethodPost, endpoint, data.Reader())
		if err != nil {
			if ctx.Err() != nil {
				return context.Cause(ctx) // is timeout etc
			}
			return err
		}
		req.Header.Set("Content-Type", "application/json")
		resp, err := http.DefaultClient.Do(req)
		if err != nil { // maybe bad markdown, send a simple message as a fallback
			if ctx.Err() != nil {
				return context.Cause(ctx) // is timeout etc
			}
			log.Info("failed to send chain alert", "msg", data.Text, "error", err.Error())
			return err
		}
		body, err := io.ReadAll(resp.Body)
		resp.Body.Close()
		if resp.StatusCode != http.StatusOK {
			return fmt.Errorf("unexpected status code: %d", resp.StatusCode)
		}
		if err != nil {
			return fmt.Errorf("failed to read response body: %w", err)
		}
		if len(body) > 0 {
			log.Info("telegram alert response", "msg", string(body))
		}

	}
	return nil
}
